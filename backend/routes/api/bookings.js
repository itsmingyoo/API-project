const express = require("express");
const { Op } = require("sequelize");
const { Spot, SpotImage, Booking } = require("../../db/models");
const { check } = require("express-validator");
const { handleValidationErrors } = require("../../utils/validation");
const { setTokenCookie, requireAuth } = require("../../utils/auth");
const router = express.Router();

// find all bookings of current user
router.get("/current", requireAuth, async (req, res) => {
  let allBookings = await Booking.findAll({
    attributes: [
      "id",
      "spotId",
      "userId",
      "startDate",
      "endDate",
      "createdAt",
      "updatedAt",
    ],
    where: {
      userId: req.user.id,
    },
    include: {
      model: Spot,
      include: {
        model: SpotImage,
        attributes: [["url", "previewImage"]],
      },
    },
  });
  const bookingsJSON = allBookings.map((booking) => {
    booking = booking.toJSON();
    if (booking.Spot.SpotImages.length) {
      booking.Spot.previewImage = booking.Spot.SpotImages[0].previewImage;
      // console.log(booking);
      // console.log(booking.Spot.SpotImages[0].previewImage);
    } else {
      booking.Spot.previewImage = null;
    }
    delete booking.Spot["createdAt"];
    delete booking.Spot["updatedAt"];
    delete booking.Spot["SpotImages"];
    return booking;
  });
  res.json({ Bookings: bookingsJSON });
});

// edit a booking
router.put("/:bookingId", requireAuth, async (req, res) => {
  let book = await Booking.findByPk(req.params.bookingId);

  if (!book) {
    res.status(404);
    return res.json({
      message: "Booking couldn't be found",
    });
  }
  if (book.userId !== req.user.id) {
    res.status(400);
    return res.json({
      message: "Booking must belong to user.",
    });
  }

  // let spot = await Spot.findByPk(book.spotId);

  // let allBookings = await spot.getBookings({
  //   where: {
  //     id: {
  //       [Op.ne]: book.id,
  //     },
  //   },
  // });
  // return res.json(allBookings);

  book = book.toJSON();

  const conflictError = {
    message: "Sorry, this spot is already booked for the specified dates",
    errors: {
      startDate: "Start date conflicts with an existing booking",
      endDate: "End date conflicts with an existing booking",
    },
  };

  const { startDate, endDate } = req.body;
  const startDateReq = new Date(startDate).getTime();
  const endDateReq = new Date(endDate).getTime();
  const currentDate = new Date().getTime();
  const bookStart = new Date(book.startDate).getTime();
  const bookEnd = new Date(book.endDate).getTime();

  // start date cannot be after end date
  if (startDateReq > endDateReq) {
    res.status(400);
    return res.json({
      message: "Bad Request", // (or "Validation error" if generated by Sequelize),
      errors: {
        endDate: "endDate cannot come before startDate",
      },
    });
  }

  // past booking cannot be updated
  if (currentDate > endDateReq) {
    res.status(403);
    return res.json({
      message: "Past bookings can't be modified",
    });
  }

  // bookstart -- user start request -- bookend
  if (startDateReq >= bookStart && startDateReq <= bookEnd) {
    res.status(403);
    return res.json(conflictError);
  }

  // bookstart -- user end request -- bookend
  if (endDateReq >= bookStart && endDateReq <= bookEnd) {
    res.status(403);
    return res.json(conflictError);
  }

  // user start request -- current date
  if (startDateReq < currentDate || endDateReq < currentDate) {
    res.status(403);
    return res.json({
      message: "Must be a valid date that is after the current date.",
    });
  }

  // update
  if (req.user.id === book.userId) {
    if (startDate) book.startDate = startDate;
    if (endDate) book.endDate = endDate;
    await book.save;
  }

  res.json(book);
});

// delete a booking
router.delete("/:bookingId", requireAuth, async (req, res) => {
  const book = await Booking.findByPk(req.params.bookingId);
  if (!book) {
    res.status(404);
    return res.json({
      message: "Booking couldn't be found",
    });
  }
  const currentDate = new Date().getTime();
  const bookStarter = new Date(book.startDate).getTime();
  const bookEnder = new Date(book.endDate).getTime();

  if (currentDate > bookStarter && currentDate < bookEnder) {
    res.status(403);
    return res.json({
      message: "Bookings that have been started can't be deleted",
    });
  }
  if (book.userId === req.user.id) {
    book.destroy();
    res.json({
      message: "Successfully deleted",
    });
  } else {
    res.json({
      message: "Booking must belong to user.",
    });
  }
});

module.exports = router;
